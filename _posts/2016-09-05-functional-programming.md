---
layout: post
title: "聊聊函数式编程"
date: "2016-09-05 12:00:00"
timezone: Asia/Hong_Kong
---

# 前言

作为一个存在了一个世纪,比汇编还要古老的东西,[函数式编程](https://en.wikipedia.org/wiki/Functional_programming)
总是保持着自己的神秘气息,尤其是在笔者身处的前端领域,往往沾之丝毫立即显得高大上许多
(比如[redux](https://github.com/reactjs/redux))。那么本篇的内容就是要揭一揭它
的神秘面纱,希望读者即使掌握不了函数式编程的精髓拿去吹,也不会两眼一抹黑被轻易唬住。
当然了本篇不会教会你任何编程技巧或者函数式编程语言, 想要了解这一块的看官怕是要失望啦

# 那么,究竟什么是函数式编程呢?

函数式编程是一个很古老的概念,从本质上来讲是一种编程范式,和过程式编程、面向对象编程等
是并列的概念。函数式编程和数学的关系密切不可分,早在现代计算机被发明出来之前,就有了对
基于推导的计算机程序解决问题的研究。历史上最古老的函数式编程语言,大名鼎鼎的LISP,甚至
比汇编、C语言更早诞生。

相对于常规的过程式编程所注重的程序严格按顺序执行,函数式编程注重程序的结果。首先一个已
经被解决的问题可以直接被复用到另一处,另外计算的顺序不重要,所以一些计算过程可以被延迟。

## 规则一、已解决的问题可以被直接复用

> 一天，数学家觉得自己已经受够了数学，于是他跑到消防队去宣布他想当消防员。 
> 消防队长说：“您看上去不错，可是我得先给您一个测试。” 
> 消防队长带数学家到消防队后院小巷，巷子里有一个货栈、一只消火栓和一卷软管。 
> 消防队长问：“假设货栈起火，您怎么办？” 
> 数学家回答：“我把消火栓接到软管上，打开水龙，把火浇灭。” 
> 消防队长说：“完全正确！最后一个问题：假设您走进小巷，而货栈没有起火，您怎么办？” 
> 数学家疑惑地思索了半天，终于答道：“我就把货栈点着。” 
> 消防队长大叫起来：“什么？太可怕了！您为什么要把货栈点着？” 
> 数学家回答：“这样我就把问题简化为一个我已经解决过的问题了。”

当然这只是个讽刺笑话,但很好地阐述了这个规则的含义。假如我们要计算`1,2,...,100`的和,
当然我们没有高斯那么聪明,只能一个个累加。对于面向过程编程语言,我们会很熟练地写出一段
循环:

```js
let sum = 0;
for(let i = 1; i <= 100; i++) {
    sum = sum + i;
}
print(sum);
```

甚至更进一步,我们还能把它封装成一个函数,计算1到任意值的和:

```js
function sum(n) {
  let sum = 0;
  for(let i = 1; i <= n; i++) {
    sum = sum + i;
  }
  return sum;
}
```

那么问题来了: 如果我们已知1到100的和是5050, 如何求1到101的和? 按照上面的代码实现,
每来一个新的数字,我们都要把以前的计算重复一次,就像我们明明知道了`1+2+...+100=5050`,
要计算`1+2+...+100+101`还是要把之前的100个数字加一遍。(真是叔可忍婶也不可忍啊! 数
学家快来拯救我吧!)

### 数学上的函数

咳咳,今天我们要讨论的数学范畴绝对不回超过初中课程,看官大可不必被数学两字吓跑。既然要
扯到数学,先约定一套讨论用的规则还是比较好的。

我们定义一个数学上的函数: `f(x)`, 代表一个名为`f`的函数, 接受一个变量`x`, 返回一个结果的一个计算规则。对计
算规则的描述可以通过按照结合律书写的数学表达式来表示。比如:

    f(x) = x + 1

如果我们限定x为自然数,那么`f(x)`代表接受一个自然数x,返回其后继自然数的函数。

那么怎么用数学函数描述1到n的和呢? 我们知道有通项公式: `sum(n) = n * (n + 1) / 2`,
但我们没有高斯这么聪明, 不会计算通项公式, 怎么办呢? 嗯至少上面的100和101问题给了我们
一个思路, 我们可以定义一个函数:

    sum(1) = 1
    sum(n) = n + sum(n - 1)

这里面用到了我们说到的规则一: 已解决的问题可以被直接复用。如果`sum(100)`这个问题已
经解决了,那么计算`sum(101)`的时候我们可以直接复用它的结果, 然后加上一个101么? (当然
可以了。)

### 递归地思考

当然上面的例子还涉及到了另一个编程知识范畴, 我们称之为**递归**。无论是现实世界还是虚
拟的理论世界,递归无处不在。(比如我们怎么定义一根树枝? 一根树枝应该是主干和上面的分叉
所组成的整体,那么分叉是不是树枝?) [EoPL](https://mitpress.mit.edu/books/essentials-programming-languages)
第一章第一节讲的就是递归, 可见它对于编程语言的重要性。我们至少可以从以下两个方面去理解
递归:

#### 递归的数据

有些数据(比如你午饭吃了么?) 是可以枚举的(`{"吃了", "没吃"}`), 而更多的数据是无法
枚举的。比如如果问一个人你几岁了(或者天上有多少个星星), 实际可能的值要从0枚举到宇宙
的年龄。幸好我们有归纳法这一神器, 可以不用枚举,而用归纳的方式来定义数据。比如我们定义
自然数N为满足以下条件的数字n的集合:

  - n = 0, or
  - n - 1 ∈ N

上面的定义可能并不直观, 但是我们可以改写成这样: 

  - n = 0 ∈ N, and
  - if n - 1 ∈ N, then n ∈ N

当然上面的两种定义是等价的!

不过,难道只有"重新定义自然数"这种无聊的行为才能用到递归么? 我们暂且脱离需要重新定义
自然数这个蛮荒年代, 来看一个复杂的数据结构: `JSON数据`, 它的取值可以是:

  - 数字, or
  - 布尔值, or
  - null, or
  - 数组, or
  - 对象

而`数组`的定义是

  - 空数组, or
  - 数组:JSON数据
  
在这里, `:`操作符表示把一个数据附加到一个序列后面。比如`[3,4]:5 = [3,4,5]`。就像
从0可以构造出所有自然数,从空数组可以构造出所有的数组,只要通过归纳法。

此外, `数组`的定义中使用了`JSON数据`的概念, 而`JSON数据`的定义也使用了`数组`的概念, 
这看起来挺诡异的, 不过反正能解决问题嘛,啊哈哈哈哈哈。。。

#### 递归的算法

除了数据, 算法也可以是递归的, 比如上面的`sum(n) = n + sum(n - 1)`, 就是一种递归
的定义算法的过程。对于常见的程序, 除非是计算`1 + 1 = ?`这种问题, 我们几乎都可以把
问题分割出一些递归的子问题。

当然递归的核心思想就是对已解决的问题的复用, 前提是无论计算多少次, 1到100的和永远都
不会发生变化。所以如果我们曾经计算过了1到100的和,下次计算1到101的和就可以复用其结果
了。这也是函数式编程的一个核心原则:

> 一个函数以同样的参数多次调用, 应该返回相同的结果

另一个派生原则就是

> 函数内部不应该影响外部上下文
    
第一句话好理解(如果返回结果变了,就没发复用了嘛!), 第二句话的意思是: 因为函数的返回值
可能会被复用, 那么一次函数调用是否真实进行了函数内部的计算过程不可知, 而函数被调用与
否又不应该从外部环境看出来,所以函数内部不能影响外部上下文。

理解了以上信息,我们来看看结果复用的威力吧!

假如要计算斐波那契数列(1,1,2,3,5,8,...)的第n项, 我们可以定义以下函数:

    F(1) = 1
    F(2) = 1
    F(n) = F(n - 2) + F(n - 1)

如果没有结果的复用,这个算法要计算多少次加法呢?

  - `F(3) = F(1) + F(2)`, 需要计算1次加法
  - `F(4) = F(2) + F(3)`, 需要计算1+1=2次加法
  - `F(5) = F(3) + F(4)`, 需要计算1+2+1=4次加法
  - `F(6) = F(4) + F(5)`, 需要计算2+4+1=8次加法
  - ...
  - `F(n) = F(n - 2) + F(n - 1)`, 需要计算2^(n-3)次加法

这是一个指数复杂度的算法, n每加一,需要的计算时间就翻倍! 如果计算`F(10)`需要1秒钟,
那么计算`F(20)`就需要1000秒,计算`F(30)`就需要3年, 计算`F(100)`需要多久?

而如果有了结果的复用, 这个复杂度就变成线性复杂度了。所以如果我们用函数式编程范式写代
码的话,切记要遵循上面的两个原则。

## 规则二、一些计算可能被延迟

假如我们有一个算法(类似斐波那契算法), 它会生成一系列的数字, 然后我们从结果中尝试
找到一个数字: 它是11的倍数。对于面向过程的编程, 我们可以这么写:

```js
function find_matching() {
  let i = 1;
  while(true) {
      let num = F(i++);
      if(num % 11 === 0) {
         // print("found it!")
         return num
      }
  }
}
```

现在我们来考虑这个问题: 如果没有告诉你这段程序想干嘛, 你能一眼看出来他是干什么的么?

我们再来尝试用数学语言描述这个问题

    # 定义一个要遍历的集合
    let xs = {F(n) | n <- {1,2,...}}
    # 对集合进行遍历
    let matches = {num | num <- xs, num % 11 == 0}
    # 取第一个match的结果
    let result = get_first(matches)

这里我们使用了`{1,2,...}`这种表述,我们称之为`range`或`sequence`。一个`range`通常
由`start` `step` `end`三部分确定(当然在这里`end`是正无穷)。而`n <- {1,2,...}`
代表n穷举了这个`range`的所有可能取值。最后, `{F(n) | n <- ...}`代表对所有的n的取值,
计算`F(n)`并形成另一个`sequence`。

使用面向过程的语言描述的话, 上述过程可以改写为

```js
let xs = map(range(1, 1, Infinity), F)
let matches = filter(xs, num => num % 11 == 0)
let result = get_first(matches)
```

注意到这里xs, matches都是无穷列表! (前者包含`[1,1,2,3,5,8,13,...]`, 后者包含
`[55,6765,832040,102334155,7480109186,...]`) 我们以前的编程经验里, 无穷
列表是没法遍历计算的, 因为CPU/内存等计算资源有限。而在上面的伪代码里, 我们经过观察
发现, 最终一步返回的值只是`matches`的第一项, 所以`matches`的后面的实际数值是无需
计算的; 而计算`matches`的第一项只需要`xs`的前10项, 所以`xs`的第10项后面的实际数
值也是不用计算的。所以虽然"把`matches`打印出来"这个命令会执行到宇宙毁灭, 但"取matches第一项"
这个命令会很快返回。

所以我们这里引入了**惰性求值**(或者叫**延迟计算**)。在一开始, 我们只需要给出`xs`的生成规则,
当我们需要取`xs`的第n项时, 才真正计算其第n项的值。那么这种生成规则应该怎么程序化表述呢?

### 惰性求值与生成器

对于上面的场景, 由于取值的过程是依次进行的, 我们可以通过**生成器**的方式来描述这一过程:

```js
function range(start, step, end) {
  return {
    [Symbol.iterator]: function* () {
      for(let value = start; value <= end; value+= step) {
        yield value
      }
    }
  }
}
```

`range(1, 1, Infinity)`返回了一个**迭代器**, 每次迭代都会遍历所有正整数。
对于迭代器的常见计算包括映射、过滤、折叠等。

#### map

`map`是将一个迭代器映射成新的迭代器。对新的迭代器进行遍历,将会遍历旧的迭代器,
并将结果通过映射函数进行映射。它的实现类似于:

```js
function map(iterable, fn) {
  return {
    [Symbol.iterator]: function* () {
      for(let value of iterable) {
        yield fn(value)
      }
    }
  }
}
```

`map`操作常常用于将上一个函数的结果进行遍历处理, 并作为下一个函数的输入。在这里只需要书写处理过程,
而无需关注处理逻辑。

#### filter

`filter`是对迭代器的值进行过滤,并返回新的迭代器, 其中只保留符合条件的值。它的实现形如:

```js
function filter(iterable, tester) {
  return {
    [Symbol.iterator]: function* () {
      for(let value of iterable) {
        if(tester(value)) yield value
      }
    }
  }
}
```
#### fold

`fold`是对迭代器进行遍历, 根据一个初始结果, 计算新的结果, 用于下一次迭代的过程。遍历结束后,
会返回最终的结果。折叠一个比较复杂的概念, 根据折叠的方向,又可以分为左折叠和右折叠。

左折叠的实现形如:

```js
function fold_left(iterable, reducer, initial_result) {
  let result = initial_result;
  for(let value of iterable) {
    result = reducer(value, result)
  }
  return result
}
```

右折叠较之左折叠更为复杂, 它从序列的末尾开始,向序列头进行折叠。它实现形如:

```js
function fold_right(iterable, reducer, initial_result) {
  let iterator = iterable[Symbol.iterator](); 
  
  function recursive() {
    let next = iterator.next();
    if(next.done) {
      return initial_result;
    }
    return reducer(next.value, recursive());
  }
  
  return recursive();
}
```

这里我们用到了一个递归实现了右折叠。逐层调用`recursive()`对iterator进行遍历, 最后再反向地使用reducer
对结果进行折叠。

#### 无穷序列的折叠

相对于映射/过滤,折叠操作需要遍历所有的值才能得到最终结果。看起来`map` `filter`似乎很容易惰性化,
而`fold`似乎根本没办法惰性化。如果输入的迭代器是无穷序列, 那么折叠就不会停止了, 不是么?

假设`xs`是正整数序列, 现在要从中找到是否存在大于100的数字。我们手头只有两个函数: 
一个接受一个数字, 返回其是否大于100, 一个接受两个布尔值, 如果其中一个为`True`,则返回`True`。
我们从`False`开始, 对`bools`进行左折叠(从头开始遍历), 如果`bools`包含一个值为`True`, 则`fold_left`返回`True`。

```js
let xs = range(1, 1, Infinity)
let bools = map(xs, x => x > 100)
let result = fold_left(bools, &&, False)
```

那么问题来了: `xs`是无穷序列, `bools`也是无穷序列(`{False,False,...,False,True,True,...}`),
对其进行左折叠, 难道要遍历所有的值? 我们知道了遍历在100以后就没有意义了

// 未完待续